<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { AppBuilder, gl, Shader, Material, Components, Entity } from "./fungi/engine/App.js";
import Vao, { Buf } from "./fungi/core/Vao2.js";


/* Inspiration
https://exp.v-os.ca/cartographer/
*/

//#############################################################################
(function(){new AppBuilder()
	.launch()
	.download( dl=>dl.addGrp( "shader", "./fungi/shaders/VecWColor.txt", "./fungi/shaders/BaseColor.txt" ) )
	.load_scene( false, false, true )
	.set_camera( 0, 45, 26, 0, 0, 0 )
	.add_task( init )
	.render_loop( onDraw )
	//.render_on_mouse( onDraw )
	.build().catch( (e)=>console.error("error",e) );
})();

window.addEventListener( "keydown", function(e){	
	switch( e.keyCode ){
		case 37: GridOffset[0] -= 0.2; UpdateOffset=true; break; //Left
		case 39: GridOffset[0] += 0.2; UpdateOffset=true; break; //Right
		case 38: GridOffset[1] -= 0.2; UpdateOffset=true; break; //up
		case 40: GridOffset[1] += 0.2; UpdateOffset=true; break; //Down
	}
});

//#############################################################################
function onDraw( dt, ss ){
	// Update offset only when needed.
	if( UpdateOffset ){
		 UpdateOffset = false;
		 Terrain.TransformFeedback.shader.bind().setUniform( "u_offset", GridOffset ).unbind();
	}

	Terrain.TransformFeedback.execute();

	App.ecs.sys_run();
}

//#############################################################################
function init(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// SHADER & MATERIALS
	let json	= Shader.parseInline( "inline_shader" ),
		shader	= Shader.buildFromJson( json ); //Shader.build( json.shader.name, json.vertex, json.fragment );

	if( !shader ) return false;
	Material.build( shader, json.materials[ 0 ] );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		setup();
	return true;
}

//#############################################################################
function setup(){
	//.................................................................
	// Create Shader to process the data in the transform feedback
	let tf_names	= [ "target_pos", "follow_pos", "follow_vel" ];	// Out Variables in Transform Feedback
	let f_src		= "#version 300 es\nprecision mediump float; out vec4 outColor; void main(void){ outColor = vec4(1.0); }";
	let v_src		= document.getElementById("feedback").innerText;
	let sh			= Shader.build( "TF_test", v_src, f_src, tf_names );

	Shader.prepareUniformBlock( sh, "UBOGlobal" );
	Shader.prepareUniform( sh, "u_offset", "vec2" );
	sh.bind().setUniform( "u_offset", GridOffset ).unbind();

	//.................................................................
	let grid_size	= 20;
	let grid_div 	= 40;

	// Create Data
	let verts		= Grid.points( grid_size, grid_div );
	let index		= Grid.line_indices( grid_div );
	let coords		= Grid.coords( grid_div );
	let zeros		= new Float32Array( verts.length );

	// Create some read only static buffers that will be shared in various Vaos.
	let bCoords 	= Buf.new_array( coords );
	let bIndex 		= Buf.new_element( index );

	// Build Transformm Feedback Entity
	let e = App.$Draw( "Grid" );
	TransformFeedback.$( e, sh, (i)=>{
		let target_pos	= Buf.new_array( verts, false, false ),	// Dynamic Buffer to Hold Target Position ( Resting Position )
			follow_pos	= Buf.new_array( verts, false, false ),	// Vertex Position 
			follow_vel	= Buf.new_array( zeros, false, true );	// Vertex Velocity

		//..............................
		// Build Transform Vao: this is used to Read Data from
		i.vao_tf.bind()
			.add_buf( "target_pos",	target_pos,	0 )
			.add_buf( "follow_pos",	follow_pos,	1 )
			.add_buf( "follow_vel",	follow_vel,	2 )
			.add_buf( "coords", 	bCoords,	3, 2 )
			.unbind_all()
			.set( verts.length / 3 ); //TODO incase of prop, unbind buf only, unbind vao after tf
		
		//..............................
		// Build Transform Feedback : This defines what buffers will be written to.
		i.tf.bind()
			.bind_buf( 0, target_pos )
			.bind_buf( 1, follow_pos )
			.bind_buf( 2, follow_vel )
			.unbind();

		//..............................
		// This will draw the data as lines
		i.vao_draw.bind()
			.add_vertices( follow_pos )
			.add_indices( bIndex )
			.unbind_all()
			.set( index.length );

		//..............................
		// This will draw the data as points
		i.vao_draw2 = new Vao(); 
		i.vao_draw2.bind()
			.add_vertices( follow_pos )
			.unbind_all()
			.set( verts.length / 3 );
	} );


	e.Node.setPos( -10, 0, -10 );	// Center Grid
	Terrain = e;
}



//#############################################################################

let UpdateOffset 	= false;						// When to update the shader uniforms of the new offset values
let GridOffset		= new Float32Array( [0,0] );	// Perlin Noise offset
let Terrain			= null;							// Entity for Terrain, will render and hole transform feedback components

// Helper to Create Vertex and Indexing Data.
class Grid{
	// Create Vertex data
	static points( size, cell_div ){
		const COMP_LEN = 3;
		let col_cnt 	= cell_div + 1,
			vert_cnt	= col_cnt * col_cnt,
			inc			= size / cell_div,
			verts 		= new Float32Array( vert_cnt * COMP_LEN ),
			i, ii, x, y;

		for( i=0; i < vert_cnt; i++ ){
			ii 	= i * COMP_LEN;
			y	= Math.floor( i / col_cnt );
			x	= i - col_cnt * y;

			//App.debug.rawPoint( x * inc, 0, y * inc );
			verts[ ii + 0 ] = x * inc;
			verts[ ii + 1 ] = 0.1;
			verts[ ii + 2 ] = y * inc;
			//verts[ ii + 3 ] = i;
		}

		return verts;
	}

	// Create indices to create lines based on the grid vertices	
	static line_indices( cell_div ){
		let col_cnt 	= cell_div + 1,
			vert_cnt	= col_cnt * col_cnt,
			line_cnt	= cell_div * col_cnt * 2, // cellCnt * (CellRows) * 2(which means vert and horz)
			idx 		= new Uint16Array( line_cnt * 2 ),
			ii 			= 0,
			i, x, y;

		for( i=0; i < vert_cnt; i++ ){
			y	= Math.floor( i / col_cnt );
			x	= i - col_cnt * y;

			if( y < cell_div ){ // Vertical Line
				idx[ ii++ ] = i;
				idx[ ii++ ] = i + col_cnt;
			}

			if( x < cell_div ){ // Vertical Line
				idx[ ii++ ] = i;
				idx[ ii++ ] = i + 1;
			}
		}

		return idx;
	}

	// XY grid coords
	static coords( cell_div ){
		const COMP_LEN = 2;
		let col_cnt 	= cell_div + 1,
			vert_cnt	= col_cnt * col_cnt,
			out 		= new Float32Array( vert_cnt * COMP_LEN ),
			i, ii, x, y;

		for( i=0; i < vert_cnt; i++ ){
			ii 	= i * COMP_LEN;
			y	= Math.floor( i / col_cnt );
			x	= i - col_cnt * y;
			out[ ii + 0 ] = x;
			out[ ii + 1 ] = y;
		}
		return out;
	}
}


//#############################################################################
// Simple ECS Component to Hold TF Data and how to execute it.
/*
TransformFeedback can be setup in different ways, but this object is designed to break
TF into two steps with shared buffers that alternate ping-pong style for execution
and rendering.

For computing we have a Vao that works as a Data Reader, then a TransformFeedback object
to work as a Data Writer. Then we have an extra Vao that will contain the buffers needed
for rendering. 

The Read Vao, Write Tf, Render Vao will be setup as Pairs, A and B. The way it works is that a shader
will Read from A, Write to B, Render From B. Next game loop we alternate, Read From B,
write to A, Render from A. Just continue alternating, which results in the concept of a
Transform Feedback.
*/
class TransformFeedback{
	static $( e, shader, func ){
		if( e instanceof Entity && !e.TransformFeedback ) Entity.com_fromName( e, "TransformFeedback" );

		e.TransformFeedback.build( func );
		e.TransformFeedback.shader = shader;
		e.TransformFeedback.entity = e;
		e.Draw.add( null, "VecColor", 1 );
		e.Draw.add( null, "VecColor", 0 );

		return e;
	}

	constructor(){
		this.data = [ 
			{ vao_tf:new Vao(), tf:new Tffb(), vao_draw:new Vao() }, 
			{ vao_tf:new Vao(), tf:new Tffb(), vao_draw:new Vao() }
		];

		this.current_idx	= 0;
		this.shader 		= null;
		this.entity			= null;
	}

	build( func ){
		func( this.data[0] );
		func( this.data[1] );
	}

	execute(){
		let i 	= (this.current_idx + 1) & 1,
			r	= this.data[ this.current_idx ],
			w	= this.data[ i ];

		gl.ctx.useProgram( this.shader.program );

		gl.ctx.bindVertexArray( r.vao_tf.id );								// Set Buffer to Read From
		gl.ctx.bindTransformFeedback( gl.ctx.TRANSFORM_FEEDBACK, w.tf.id );	// Set Buffer to Write To
		gl.ctx.enable( gl.ctx.RASTERIZER_DISCARD );							// Disable Fragment Program (only need vertex for this)

		gl.ctx.beginTransformFeedback( gl.ctx.POINTS );						// Begin Feedback Process
		gl.ctx.drawArrays( gl.ctx.POINTS, 0, r.vao_tf.elmCount );			// Execute Feedback Shader.
		gl.ctx.endTransformFeedback();	

		gl.ctx.disable( gl.ctx.RASTERIZER_DISCARD );						// Enable Fragment Program so we can draw to framebuffer
		gl.ctx.bindTransformFeedback( gl.ctx.TRANSFORM_FEEDBACK, null );
		gl.ctx.bindVertexArray( null );

		gl.ctx.useProgram( null );

		this.current_idx = i;												// Move to Next Data Index
		this.entity.Draw.items[0].vao = this.data[i].vao_draw;
		this.entity.Draw.items[1].vao = this.data[i].vao_draw2;
	}
} Components( TransformFeedback );

//#############################################################################
// Tiny TransformFeedback object, similar to the Vao object
class Tffb{
	constructor(){
		this.id = gl.ctx.createTransformFeedback();
	}

	bind_buf( loc, buf ){ gl.ctx.bindBufferBase( gl.ctx.TRANSFORM_FEEDBACK_BUFFER, loc, buf ); return this; }
	unbind(){ gl.ctx.bindTransformFeedback( gl.ctx.TRANSFORM_FEEDBACK, null ); return this; }
	bind(){ gl.ctx.bindTransformFeedback( gl.ctx.TRANSFORM_FEEDBACK, this.id ); return this; }
}

</script><body>

<script id="feedback" type="plain/text">#version 300 es
	layout(location=0) in vec3 a_target_pos;	
	layout(location=1) in vec3 a_follow_pos;
	layout(location=2) in vec3 a_follow_vel;
	layout(location=3) in vec2 a_coords;
	
	out vec3 target_pos;
	out vec3 follow_pos;
	out vec3 follow_vel;

	uniform UBOGlobal{
		mat4	projViewMatrix;
		vec3	cameraPos;
		float	globalTime;
		vec2	screenSize;
		float	deltaTime;
	};

	uniform vec2 u_offset;

	vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
	float snoise(vec2 v){
	  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
	           -0.577350269189626, 0.024390243902439);
	  vec2 i  = floor(v + dot(v, C.yy) );
	  vec2 x0 = v -   i + dot(i, C.xx);
	  vec2 i1;
	  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
	  vec4 x12 = x0.xyxy + C.xxzz;
	  x12.xy -= i1;
	  i = mod(i, 289.0);
	  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
	  + i.x + vec3(0.0, i1.x, 1.0 ));
	  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
	    dot(x12.zw,x12.zw)), 0.0);
	  m = m*m ;
	  m = m*m ;
	  vec3 x = 2.0 * fract(p * C.www) - 1.0;
	  vec3 h = abs(x) - 0.5;
	  vec3 ox = floor(x + 0.5);
	  vec3 a0 = x - ox;
	  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
	  vec3 g;
	  g.x  = a0.x  * x0.x  + h.x  * x0.y;
	  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
	  return 130.0 * dot(m, g);
	}

	const float HEIGHT		= 5.0;
	const float DAMP_RATIO	= 0.25;
	const float OSC_PS		= 6.283185307179586 * 1.0;
	const float FREQ 		= 0.040;

	void main(void){
		// semi_implicit_euler_vec3
  		// vel += -2.0 * dt * damp_ratio * osc_ps * vel + dt * osc_ps * osc_ps * (to - pos);
  		// pos += dt * vel;

  		target_pos		= a_target_pos;
  		target_pos.y	= clamp( HEIGHT * snoise( a_coords * FREQ + u_offset ), 0.0, HEIGHT );

  		follow_vel 		= a_follow_vel + ( -2.0 * deltaTime * DAMP_RATIO * OSC_PS * a_follow_vel + deltaTime * OSC_PS * OSC_PS * (target_pos - a_follow_pos));
  		follow_pos 		= a_follow_pos + deltaTime * follow_vel;
	}
</script>


<script id="inline_shader" type="plain/text">
<shader>{
	"name"		: "VecColor",
	"ubo"		: [ "UBOGlobal", "UBOModel" ],
	"uniforms"	: [
		{ "name":"u_colorAry", "type":"rgb" }
	]
}<\shader>

<materials>[
	{ "name":"VecColor",	
		"options"	: { "depthTest":true, "blend":true, "sampleAlphaCoverage":false },
		"uniforms"	: [
			{ "name" : "u_colorAry", "value" : ["1ca3ec","e7d1b5","4cba5f","208d4e","208d4e","ffffff","ffffff","ff7f7f","ff8c00","ffff00"] }
		]
	}
]<\materials>

<vertex>
	#version 300 es
	layout(location=0) in vec3 a_position;

	uniform UBOGlobal{
		mat4	projViewMatrix;
		vec3	cameraPos;
		float	globalTime;
		vec2	screenSize;
		float	deltaTime;
	};

	uniform UBOModel{
		mat4 	modelMatrix;
		mat3	normalMatrix;
	};

	uniform vec3 u_colorAry[20];
	out vec3 v_color;

	const float HEIGHT = 5.0;
	const float COL_LEN = 6.0;

	void main(void){
		float t = clamp( a_position.y / HEIGHT, 0.0, 1.0 );	// normalize the height
		float p = t * COL_LEN;								// Figure out which color to use from the color array
		int i = int( floor( p ) );							// Get the start color
		float tt = fract( p );								// How much to transition from start color to next one
		v_color			= mix( u_colorAry[ i ], u_colorAry[ i+1 ], tt );
		 
		gl_PointSize 	= 7.0;
		gl_Position 	= projViewMatrix * modelMatrix * vec4(a_position.xyz, 1.0);
	}
<\vertex>

<fragment>
	#version 300 es
	precision mediump float;

	const vec2 UV_CENTER = vec2( 0.5 ); 

	in vec3 v_color;
	out vec4 oFragColor;

	void main(void){ 
		vec2 coord = gl_PointCoord - UV_CENTER;
		//if( length(coord) > 0.5 ) discard;

		oFragColor = vec4( v_color, smoothstep( 0.5, 0.45, length(coord) ) );
		
		//oFragColor = vec4(v_color, 1.0);
	}
<\fragment>	
</script>

</body></html>