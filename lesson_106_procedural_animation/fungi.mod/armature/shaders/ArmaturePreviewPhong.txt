<shader>{
	"name"		: "ArmaturePreviewPhong",
	"ubo"		: [ "UBOTransform", "UBOModel", "UBOLighting" ],
	"options"	: { "modelMatrix":true },
	"uniforms"	: []
}<\shader>
	
<materials>[
	{ "name":"ArmaturePreviewPhong", "options": { "depthTest":false } }
]<\materials>
	
<vertex>
	#version 300 es
	layout(location=0) in vec4 a_position;

	layout(location=8) in vec4 a_QR; //Rotation
	layout(location=9) in vec4 a_QD; //Position
	layout(location=10) in float a_length;

	uniform UBOTransform{
		mat4 	projViewMatrix;
		vec3	cameraPos;
		float	globalTime;
		vec2	screenSize;
	};

	uniform UBOModel{
		mat4 	modelMatrix;
		mat3	normalMatrix;
	};


	out vec3 v_cameraPos;
	out vec3 v_worldPos;

	//https://github.com/robertsdionne/animus/blob/master/src/animus.htm
	//https://www.cs.utah.edu/~ladislav/dq/dqs.cg
	//http://donw.io/post/dual-quaternion-skinning/
	vec3 dqTransform(vec4 Qr, vec4 Qd, vec3 v){
		//Normalize - For my data I dont really need it but keep the src incase I do.
		//float len = 1.0 / length(Qr);
		//Qr *= len;
		//Qd *= len;

		//dqsFast example from dqs.cg has v + 2.0 * cross which allows rotation to work but translation fails
		//but thanks to a shader written by robertsdionne, he changed it to v + cross(2.0 *
		//Moving the 2.0 multiplication into the first cross makes it works correctly in webgl - SketchpunkLabs
		vec3 pos	= v + cross(2.0 * Qr.xyz, cross(Qr.xyz, v) + Qr.w * v);			//Rotate Vector
		vec3 tran	= 2.0 * (Qr.w * Qd.xyz - Qd.w * Qr.xyz + cross(Qr.xyz, Qd.xyz));	//Pull out Translation from DQ
		return pos + tran;
	}

	void main(void){
		gl_PointSize = 5.0;
		v_cameraPos = cameraPos;

		//Resize Bone Length based on w value
		vec4 pos = a_position;
		if(a_position.w == 1.0) pos.y = a_length;

		//Calculate World Position of the vertex
		pos	= modelMatrix * vec4(pos.xyz,1.0);
		v_worldPos	= pos.xyz;

		//Transform Vertex based on Dual Quat of the Bones Position/Rotation
		pos.xyz = dqTransform(a_QR, a_QD, pos.xyz);
		gl_Position = projViewMatrix * pos;
	}
<\vertex>

<fragment>
	#version 300 es
	precision mediump float;

	uniform UBOLighting{
		vec3 lightPosition;
		vec3 lightDirection;
		vec3 lightColor;
	};

	in vec3 v_cameraPos;
	in vec3 v_worldPos;

	out vec4 oFragColor;

	const vec3 uBaseColor			= vec3(1.0, 0.498, 0.498); //ff 7f 7f
	const float uAmbientStrength	= 0.5;
	const float uDiffuseStrength	= 0.5;
	const float uSpecularStrength	= 0.2f;	//0.15
	const float uSpecularShininess	= 1.0f; //256.0

	vec4 phongLight(vec3 norm, vec3 vertPos, vec3 camPos){
		//Ambient Lighting
		vec3 cAmbient		= lightColor * uAmbientStrength;
		
		//Diffuse Lighting
		vec3 lightVector	= normalize(lightPosition - vertPos);	//light direction based on pixel world position
		float diffuseAngle	= max( dot(norm,lightVector) ,0.0);		//Angle between Light Direction and Pixel Direction (1==90d)
		vec3 cDiffuse		= lightColor * diffuseAngle * uDiffuseStrength;

		//Specular Lighting
		vec3 camVector		= normalize(camPos - vertPos);		//Camera Direction based on pixel world position
		vec3 reflectVector	= reflect(-lightVector, norm);		//Reflective direction of line from pixel direction as pivot.
		float specular		= pow( max( dot(reflectVector,camVector) ,0.0), uSpecularShininess ); //Angle of reflected light and camera eye
		vec3 cSpecular		= lightColor * specular * uSpecularStrength;

		//Final Color
		return vec4(uBaseColor * (cAmbient + cDiffuse + cSpecular), 1.0);
	}

	vec3 lowPolyNormal(vec3 vertPos){  //Calc the Normal of the Rasterizing Pixel
		return normalize( cross( dFdx(vertPos), dFdy(vertPos) ) );
	}

	void main(void){
		oFragColor = phongLight( lowPolyNormal(v_worldPos) , v_worldPos, v_cameraPos);
	}
<\fragment>