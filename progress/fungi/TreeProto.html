<!DOCTYPE html>
<html>
	<head>
		<style>
			html,body{margin:0px; padding:0px; width:100%; height:100%;}
			body{background-color:#404040;}
			canvas{border:0px solid black;}
			div{display:flex; width:100%; height:100%; align-items:center; justify-content:center;}
			#lblFPS{position:absolute; top:0px; left:0px; background:gray; color:white; font-weight:bold; padding:5px 5px; width:40px; text-align:center; font-family:arial; font-size:13px;}
		</style>

		<script src="fungi.core.js"></script>
		<script src="fungi.primatives.js"></script>
		<script src="fungi.KBMCtrl.js"></script>
		<script src="fungi.Debug.js"></script>
		<script src="fungi.ext.js"></script>
		<script src="fungiApp.js"></script>

		<script src="Kai.js"></script>
		<script src="Perlin.js"></script>

		<script>
			var gModel;

			window.addEventListener("load",function(){
				FungiApp.startup();

				//.......................................................
				//Create Shaders and Materials
				var mat;
				Fungi.Shaders.New("DomShader","vertex_shader","fragment_shader")
					.prepareUniforms(Fungi.UNI_MODEL_MAT_NAME,"mat4")
					.prepareUniformBlocks(FungiApp.uboTransform,0);

				mat = Fungi.Shaders.Material.create("MatDomShader","DomShader");
				mat.drawMode = Fungi.gl.TRIANGLE_STRIP; //Fungi.gl.POINTS; //Fungi.gl.TRIANGLE_STRIP;
				mat.useCulling = false;

				Fungi.Shaders.New("LowPoly","vertex_lowpoly","fragment_lowpoly")
					.prepareUniforms(Fungi.UNI_MODEL_MAT_NAME,"mat4")
					.prepareUniformBlocks(FungiApp.uboTransform,0);
				mat = Fungi.Shaders.Material.create("MatLowPoly","LowPoly");
				mat.useCulling = true;
				mat.drawMode = Fungi.gl.TRIANGLE_STRIP; //Fungi.gl.TRIANGLE_STRIP;


				//.......................................................
				//Prepare our Renderables
				gModel = new FungiExt.DynamicMesh(4,1,1,"MatLowPoly"); // MatLowPoly MatDomShader
				gModel.drawMode = Fungi.gl.TRIANGLES; //Fungi.gl.POINTS; //Fungi.gl.TRIANGLES;
				gModel.verts.data.push(
					-1.0,0.0,-1.0,0.0,
					-1.0,0.0,1.0,1.0,
					1.0,0.0,1.0,2.0,
					1.0,0.0,-1.0,3.0
				);
				createTree(gModel);


				gModel.update();
				FungiApp.scene.push(gModel);

				//.......................................................
				//Start Render Loop
				FungiApp.renderLoop.start();
			});


			function onRender(dt){
				FungiApp.update();
				Fungi.Render(FungiApp.scene);
			}



			function createTree(gModel){
				var vData = gModel.verts.data,	//ref to vert data
					iData = gModel.index.data,	//ref to index data
					steps = 7,					//How many times to extrude the trunks
					mkHole = -1,				//When to leave holes in the trunk
					idxList = null,				//Index Array List
					idxListLast = [0,1,2,3],	//Previous Index Array List
					branches = [];				//List of indexes of where the holes are.
				
				var rx=0,						//Random X
					ry=0,						//Random Y
					s = 0;						//Scale Value

				//Create 
				for(var i=0; i < steps; i++){
					idxList = Kai.Extrude([0,0.7,0],idxListLast,vData);

					s = 1 - Math.pow(0.1,(i+1)*1.9/steps);
					Kai.Scale(idxList,[s,1,s],vData);   			//Curve
					//Kai.Scale(idxList,[0.85,1.0,0.85],vData);		//Linear
					
					ry = Kai.Rnd(0,40) * Math.PI/180;
					Kai.Rot(idxList,ry,"y",vData);

					rx = Kai.Rnd(-10,10) * Math.PI/180;
					Kai.Rot(idxList,rx,"x",vData);
					
					if(i == steps-1) mkHole = 1;
					else if(i == steps-2) mkHole = 0;
					Kai.TriWall(idxListLast,idxList,iData,mkHole,branches);

					idxListLast = idxList;
				}

				//Create Top Cap
				Kai.TriQuad(idxListLast,iData);
				
				//Create Branches in the holes created in the trunk
				var ePoints = [];
				for(var i=0; i < branches.length; i++) ePoints.push(createBranch(branches[i],vData,iData));

				//Create bushes at the end of the branches
				for(var i=0; i < ePoints.length; i++) createBush(ePoints[i]);
			}

			function createBranch(iAry,src,iData){
				var idxPrev = iAry, idxNext = null;
				var cp = [0,0,0];	//Cross Product, used to save forward direction
				var up = [0,1,0];	//Up Direction
				
				for(var i = 0; i < 5; i++){
					Kai.QuadCrossProd(idxPrev,src,cp,1);	//Figure out the forward direction to extrude
					
					if(i == 0){ //on the first extrude, want to set the forward direction a few degrees up
						var dp = Fungi.Maths.Vec3.dot(cp,up);	//Get the angle between forward and up
						var p0 = iAry[0] * 4,				 	//Use the top two points of the quad to determine a rotation axis
							p1 = iAry[3] * 4;					
						var v1 = [ src[p1] - src[p0], src[p1+1] - src[p0+1], src[p1+2] - src[p0+2] ]; //Create Direction vector		
						Kai.Norm(v1); //normalize the direction vector

						var q = new Fungi.Maths.Quaternion();
						q.setAxisAngle(v1, dp-0.3);					//set the angle a bit less then its current angle
						Fungi.Maths.Quaternion.rotateVec3(q,cp);	//use this new angle to rotate our forward direction up a bit
					}

					idxNext = Kai.Extrude(cp,idxPrev,src);		//Extrude
					
					var rad = Kai.Rnd(-45,2) * Math.PI/180;		//Random Rotation

					Kai.qRotCenter(rad,idxNext,src);			//Rotate our new vertices

					Kai.ScaleCenter(idxNext,0.60,src);			//Scale down our new vertices

					Kai.TriWall(idxPrev,idxNext,iData,-1);		//Create Faces
					
					idxPrev = idxNext;							//Save for next loop to continue extruding
				}

				//Get the center of the final quad created, this will be the position for bushes.
				var endPoint = [0,0,0];
				Kai.QuadCenterPos(idxPrev,src,endPoint)
				return endPoint;
			}

			function createBush(iniPos){
				var verSteps = 10,
					horSteps = 10,
					iRadius = Kai.Rnd(1,2);
					radius = 2;

				var i,x,y,z,
					halfPI		= Math.PI * 0.5,				//Starting Angle for Azimuth
					eleInc		= Math.PI / (verSteps-1),		//Vertical Increment
					aziInc		= Math.PI * 2 / (horSteps),		//Horizontal Increment
					elevation	= 0,							//North-South
					azimuth		= 0,							//West-East
					aryVerts	= [],//0,radius,0,0,-radius,0
					aryIndex	= [];

				for(var a=0; a < horSteps; a++){
					azimuth = Math.PI + a * aziInc;				//Inc 360 degrees

					for(i=0; i < verSteps; i++){
						//radius = Kai.Rnd(1.5,2);

						//Apply noise to any points except the poles
						if(i > 0 && i < verSteps-1) radius = iRadius + (0.6 * noise.perlin2(a*0.45,i*0.45));
						else radius = iRadius;

						//Convert the Two angles to Cord Points
						elevation = halfPI + i * eleInc;
						x = radius * Math.cos(elevation) * Math.cos(azimuth);	//X
						y = radius * Math.sin(elevation);						//Z
						z = radius * Math.cos(elevation) * Math.sin(azimuth);	//Y

						//Scale up
						x *= 1.5;
						z *= 1.5;

						aryVerts.push(x,y,z);
					}
				}

				FungiExt.Mesh.triangleStrip(horSteps,verSteps,aryIndex,true,false);
				var vao = Fungi.Shaders.VAO.standardMesh("MorphCircle",3,aryVerts,null,null,aryIndex,false);
				var model = new Fungi.Renderable(vao,"MatLowPoly");
				model.position.x = iniPos[0];
				model.position.y = iniPos[1];
				model.position.z = iniPos[2];
				FungiApp.scene.push(model);
				//var vao = Fungi.Shaders.VAO.standardMesh("MorphCircle",3,aryVerts,null,null,null,false);
				//return vao;
			}
		</script>
	</head>
<body>
	<div><canvas id="FungiCanvas"></canvas></div>
	<span id="lblFPS">0</div>

	<script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
		layout(location=0) in vec4 a_position;
		layout(location=1) in vec3 a_norm;
		layout(location=2) in vec2 a_uv;

		uniform UBOTransform{
			mat4 matProjection;
			mat4 matCameraView;
			vec3 posCamera;
		};

		uniform mat4 uModalMatrix;
		uniform mat3 uNormalMatrix;

		out highp vec2 vUV;
		out lowp vec3 color;

		void main(void){
			gl_PointSize = 12.0;
			if(a_position.w == 0.0) color = vec3(1.0,0.0,0.0);
			else if(a_position.w == 1.0) color = vec3(0.0,1.0,0.0);
			else if(a_position.w == 2.0) color = vec3(0.0,0.0,1.0);
			else if(a_position.w == 9.0) color = vec3(1.0,0.5,0.5);
			else color = vec3(0.6,0.6,0.6);

			vUV = a_uv;
			gl_Position =  matProjection * matCameraView * uModalMatrix * vec4(a_position.xyz, 1.0);
		}
	</script>
	<script id="fragment_shader" type="x-shader/x-fragment">#version 300 es
		precision mediump float;
		in highp vec2 vUV;
		in lowp vec3 color;
		out vec4 outColor;

		void main(void){
			outColor = vec4(color,1.0);
		}
	</script>

	<script id="vertex_lowpoly" type="x-shader/x-vertex">#version 300 es
		layout(location=0) in vec4 a_position;
		layout(location=1) in vec3 a_norm;
		layout(location=2) in vec2 a_uv;

		uniform UBOTransform{
			mat4 matProjection;
			mat4 matCameraView;
			vec3 posCamera;
		};

		uniform mat4 uModalMatrix;
		//uniform mat3 uNormalMatrix;

		out vec3 vWorldPos;
		out vec3 vCameraPos;
		out vec2 vLowPoly;

		const float uColumnCnt = 5.0;

		void main(void){
			//Identify Triangles in Quad, If y == 1, Then its the top triangle
			//01 01
			//00 01
			float verID	= float(gl_VertexID);
			float r		= floor(verID / uColumnCnt);
			if(mod(r,2.0) == 0.0) vLowPoly = vec2(0.0,1.0);
			else{
				// i % col == colIndex -> colIndex % 2 = 0-1
				if( mod( mod(verID,uColumnCnt) ,2.0) == 0.0) vLowPoly = vec2(0.0,0.0);
				//if( mod( verID ,2.0) == 0.0) vLowPoly = vec2(0.0,0.0);
				else vLowPoly = vec2(0.0,1.0);
			}

			//Set Out values
			vec4 wpos 	= uModalMatrix * vec4(a_position.xyz,1.0);
			vWorldPos	= wpos.xyz;
			vCameraPos	= (inverse(matCameraView) * vec4(posCamera,1.0)).xyz; //Need to pass Camera pos turned to WorldSpace avoid inverse matrix
			gl_Position	= matProjection * matCameraView * wpos;
		}
	</script>

	<script id="fragment_lowpoly" type="x-shader/x-fragment">#version 300 es
		precision mediump float;
	
		in vec3 vWorldPos;
		in vec3 vCameraPos;
		in vec2 vLowPoly;

		const vec3 uLightPos			= vec3(4.0,2.0,1.0);
		const vec3 uBaseColor			= vec3(1.0,0.5,0.5);
		const vec3 uLightColor			= vec3(1.0,1.0,1.0);

		const float uAmbientStrength	= 0.5;
		const float uDiffuseStrength	= 0.5;
		const float uSpecularStrength	= 0.2f;	//0.15
		const float uSpecularShininess	= 1.0f; //256.0

		out vec4 outColor;

		void main(void){
			float LowPolyFactor = (vLowPoly.y >= 0.9999)? 1.1 : 1.0;	//Determine LowPoly Strength
			vec3 pixelNorm = normalize( cross( dFdx(vWorldPos), dFdy(vWorldPos) ) ); //Calc the Normal of the Rasterizing Pixel

			//Ambient Lighting
			vec3 cAmbient		= uLightColor * uAmbientStrength;
			
			//Diffuse Lighting
			vec3 lightVector	= normalize(uLightPos - vWorldPos); //light direction based on pixel world position
			float diffuseAngle	= max( dot(pixelNorm,lightVector) ,0.0); //Angle between Light Direction and Pixel Direction (1==90d)
			vec3 cDiffuse		= uLightColor * diffuseAngle * uDiffuseStrength;

			//Specular Lighting
			vec3 camVector		= normalize(vCameraPos - vWorldPos); //Camera Direction based on pixel world position
			vec3 reflectVector	= reflect(-lightVector, pixelNorm); //Reflective direction of line from pixel direction as pivot.
			float specular		= pow( max( dot(reflectVector,camVector) ,0.0), uSpecularShininess ); //Angle of reflected light and camera eye
			vec3 cSpecular		= uLightColor * specular * uSpecularStrength;

			//Final Color
			outColor = vec4( uBaseColor * ((cAmbient + cDiffuse + cSpecular) * LowPolyFactor), 1.0);
		}
	</script>
</body>
</html>
